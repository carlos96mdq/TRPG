// Fill out your copyright notice in the Description page of Project Settings.


#include "BaseUnit.h"

ABaseUnit::ABaseUnit()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	// Create Skeleton Component to attach a SkeletonMesh to this unit
	Model3DComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("Body"));
	Model3DComponent->SetupAttachment(RootComponent);
	//Model3DComponent->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);
}

void ABaseUnit::Init(FName NewArchetype)
{
	Archetype = NewArchetype;
}

void ABaseUnit::BeginPlay()
{
	Super::BeginPlay();

	// Get data linked to Unit Name and save it
	FUnits* BaseStats = UnitsTable->FindRow<FUnits>(Archetype, "", true);
	check(BaseStats);
	
	// Set unit resistances using the just aquired type
	AddTypeModifiers(Type);
	AddTypeModifiers(SubType);

	// Load and reference assets needed
	Icon = BaseStats->Icon.LoadSynchronous();
	Model3D = BaseStats->Model3D.LoadSynchronous();

	// Set variable stats using the base stats
	Health = BaseStats->MaxHealth;
	Energy = BaseStats->MaxEnergy;

	//TODO inicializo las pasivas manualmente, esto deberia venir como data de algun lado
	KnownPassives.Add("Pasiva_test");

	//TODO PLACEHOLDER inicializo la tabla de acciones con algo cargado para pruebas
	EquippedCombatActions.Init(-1, 5);
	EquippedCombatActions[0] = KnownCombatActions.Add("Ember");

	// Set SkeletonMesh from datatable
	Model3DComponent->SetSkeletalMesh(Model3D);
}

void ABaseUnit::OnUnitClicked(AActor* ClickedActor, FKey ButtonPressed)
{
	//UE_LOG(LogTemp, Warning, TEXT("Unidad seleccionada"));
}


void ABaseUnit::Move(float DeltaTime)
{
	// Move
	FVector NextStep = FMath::VInterpConstantTo(
		GetActorLocation(),
		Destination,
		DeltaTime,
		1000
	);

	SetActorLocation(NextStep);

	// Verify if the unit reached the current destination and if there are new ones to reach
	if (GetActorLocation() == Destination)
	{
		if (!QueueDestinations.Dequeue(Destination))
		{
			CurrentState = UnitState::Idle;
		}
	}
}

void ABaseUnit::AddTypeModifiers(UnitType NewType)
{
}

void ABaseUnit::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	if (CurrentState == UnitState::Moving)
	{
		Move(DeltaTime);
	}
}

void ABaseUnit::MoveUnit(FVector FinalDestination)
{
	// Create a queue of destinations so the unit can travel only in a vertical and horizontal way
	QueueDestinations.Enqueue(FVector(FinalDestination.X, GetActorLocation().Y, GetActorLocation().Z));
	QueueDestinations.Enqueue(FVector(FinalDestination.X, FinalDestination.Y, GetActorLocation().Z));

	// Set the first step
	QueueDestinations.Dequeue(Destination);
}

void ABaseUnit::MoveUnit(TArray<FVector>& Path)
{
	for (int32 i = (Path.Num() - 1); i >= 0; i--) 
	{
		//FVector CurrentLocation = Path.Pop();
		FVector CurrentLocation = Path[i];
		QueueDestinations.Enqueue(FVector(CurrentLocation.X, CurrentLocation.Y, GetActorLocation().Z));
	}
	
	// Set the first step
	QueueDestinations.Dequeue(Destination);
}

void ABaseUnit::SetCombatAction(int32 ActionId)
{
	// Verify if the action used is valid
	check(ActionId >= 0 && ActionId <= 4 && EquippedCombatActions[ActionId] >= 0 && EquippedCombatActions[ActionId] < KnownCombatActions.Num());

	// Get action data from data table
	CurrentCombatAction = CombatActionsTable->FindRow<FCombatActionsStruct>(KnownCombatActions[EquippedCombatActions[ActionId]], "", true);
	check(CurrentCombatAction);
}

void ABaseUnit::UseCurrentAction(ABaseUnit* Objective)
{
	// TODO Verify if this action can be used in that objective

	// TODO Check for actions effects that are executed before accuracy check

	// Check if this action pass the accuracy check (if it hits)
	bool IsCritic = false;
	bool IsSuccess = false;
	int32 HitChanceDie = FMath::RandRange(1, 100);
	int32 HitThreshold = GetUnitStat(UnitStats::Accuracy) + CurrentCombatAction->Accuracy - Objective->GetUnitStat(UnitStats::DoggingChance);
	int32 CriticThreshold = GetUnitStat(UnitStats::CriticChance);
	
	// If it is a critic it allways hit, don't matter the objective DoggingChance 
	if (HitChanceDie <= CriticThreshold)
		IsCritic = true;
	else if (HitChanceDie <= HitThreshold)
		IsSuccess = true;

	// The action passed the accuracy check, so continue
	if (IsSuccess || IsCritic)
	{
		UE_LOG(LogTemp, Warning, TEXT("Attack hits"));
		// Calculate the final damage to apply to objective
		// Get damage generated by the attacker
		int32 Damage = CurrentCombatAction->Power + FMath::Floor((CurrentCombatAction->StrenghtMod * GetUnitStat(UnitStats::StrenghtPower) + CurrentCombatAction->DexterityMod * GetUnitStat(UnitStats::DexterityPower) + CurrentCombatAction->SpecialMod * GetUnitStat(UnitStats::DivinePower)) / 100);
		if (IsCritic)
			Damage = FMath::Floor(Damage * 1.5);

		// Reduce damage from the objective armor
		Damage -= Objective->GetUnitStat(UnitStats::Armor);
		//Damage = FMath::Floor(Damage * (1 - Objective->GetStatArmor() / 100));

		// Check for resistance in objective
		//int32 Resistance = GetStatResistance(CurrentCombatAction->DamageType);
		//Damage = FMath::Floor(Damage * (1 - Resistance / 100));
		Damage -= Objective->GetUnitResistance(CurrentCombatAction->DamageType);

		// Apply the damage to the Objective
		Objective->ApplyDamage(Damage);

		// Check for actions effects after accuracy check
		if (CurrentCombatAction->Effects.Num() > 0)
		{
			ABaseUnit* EffectObjective;
			for (const FEffects& Effect : CurrentCombatAction->Effects)
			{
				// Set the effect's objective because it can be different than the attack/skill objective
				switch (Effect.Objective)
				{
				case ObjectiveType::User:
					EffectObjective = this;
					break;
				case ObjectiveType::Enemy:
					EffectObjective = Objective;
					break;
				default:
					EffectObjective = Objective;
					break;
				}

				// Apply the effect according to the type
				switch (Effect.Type)
				{
				case EffectType::Status:
					//TODO chequear si el objetivo es inmune
					//TODO en caso de no ser inmune o resistirse, aplicarle el status
					break;
				case EffectType::Stats:
					//TODO chequear si el objetivo es inmune
					//TODO en caso de no ser inmune o resistirse, aplicarle el status
					break;
				default:
					break;
				}
			}
		}
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT("Attack missed"));
	}

	

	// TODO Remove effects that only last for this action
}

void ABaseUnit::ApplyDamage(int32 Damage)
{
	Health = Health - Damage;
	UE_LOG(LogTemp, Warning, TEXT("Current Damage: %d"), Damage);
	UE_LOG(LogTemp, Warning, TEXT("Current Health: %d"), Health);
}

void ABaseUnit::SetUnitState(UnitState NewState)
{
	CurrentState = NewState;
}

bool ABaseUnit::HasActionEquipped(int32 CombatActionSlot) const
{
	UE_LOG(LogTemp, Warning, TEXT("HasActionEquipped"));
	UE_LOG(LogTemp, Warning, TEXT("CombatActionSlot: %d, KnownCombatActions: %d"), CombatActionSlot, EquippedCombatActions[CombatActionSlot]);
	check(CombatActionSlot >= 0 && CombatActionSlot <= 4);
	if (EquippedCombatActions[CombatActionSlot] >= 0 && EquippedCombatActions[CombatActionSlot] < KnownCombatActions.Num())
		return true;
	else
		return false;
}

const int32 ABaseUnit::GetUnitStat(UnitStats Stat)
{
	int32 StatValue = 0;
	
	// Add base value coming from unit archetype base stats
	switch (Stat)
	{
	case UnitStats::Health:
		StatValue += BaseStats->MaxHealth;
		break;
	case UnitStats::Energy:
		StatValue += BaseStats->MaxEnergy;
		break;
	case UnitStats::Armor:
		StatValue += BaseStats->Armor;
		break;
	case UnitStats::StrenghtPower:
		StatValue += BaseStats->StrenghtPower;
		break;
	case UnitStats::DexterityPower:
		StatValue += BaseStats->DexterityPower;
		break;
	case UnitStats::DivinePower:
		StatValue += BaseStats->DivinePower;
		break;
	case UnitStats::Velocity:
		StatValue += BaseStats->Velocity;
		break;
	case UnitStats::Accuracy:
		StatValue += BaseStats->Accuracy;
		break;
	case UnitStats::CriticChance:
		StatValue += BaseStats->CriticChance;
		break;
	case UnitStats::DoggingChance:
		StatValue += BaseStats->DoggingChance;
		break;
	default:
		break;
	}

	// Add values coming from unit pasives
	for (FName PassiveName : KnownPassives)
	{
		FPassives* Passive = PassivesTable->FindRow<FPassives>(PassiveName, "", true);
		check(Passive);

		if (Passive->Type == PassiveType::Start)
		{
			for (const FEffects& Effect : Passive->Effects)
			{
				// Check only for effects that apply to this stat. As Start Stats Passives are initialized allways, ignore the probability check
				if (Effect.Type == EffectType::Stats && Effect.SubType == (uint8)Stat && (Effect.Objective == ObjectiveType::User || Effect.Objective == ObjectiveType::Allies))
				{
					if (Effect.IsValuePercent)
					{
						StatValue = FMath::Floor(StatValue * (1 + Effect.Value / 100));
					}
					else
					{
						StatValue += Effect.Value;
					}
				}
			}
		}
	}

	//TODO a eso agregarle cualquier modificacion surgida por el equipamiento

	//TODO finalmente tener en cuenta cualquier status que pueda afectar

	return StatValue;
}

const int32 ABaseUnit::GetUnitResistance(UnitResistances DamageType)
{
	int32 ResistanceValue = 0;

	// Add base value coming from unit archetype base stats
	switch (DamageType)
	{
	case UnitResistances::Slashing:
		ResistanceValue += BaseStats->Resistances.Slashing;
		break;
	case UnitResistances::Bludgeoning:
		ResistanceValue += BaseStats->Resistances.Bludgeoning;
		break;
	case UnitResistances::Piercing:
		ResistanceValue += BaseStats->Resistances.Piercing;
		break;
	case UnitResistances::Fire:
		ResistanceValue += BaseStats->Resistances.Fire;
		break;
	case UnitResistances::Poison:
		ResistanceValue += BaseStats->Resistances.Poison;
		break;
	case UnitResistances::Lightning:
		ResistanceValue += BaseStats->Resistances.Lightning;
		break;
	default:
		break;
	}

	// Add values coming from unit pasives
	for (FName PassiveName : KnownPassives)
	{
		FPassives* Passive = PassivesTable->FindRow<FPassives>(PassiveName, "", true);
		check(Passive);

		if (Passive->Type == PassiveType::Start)
		{
			for (const FEffects& Effect : Passive->Effects)
			{
				// Check only for effects that apply to this stat. As Start Stats Passives are initialized allways, ignore the probability check
				if (Effect.Type == EffectType::Resistances && Effect.SubType == (uint8)DamageType && (Effect.Objective == ObjectiveType::User || Effect.Objective == ObjectiveType::Allies))
				{
					if (Effect.IsValuePercent)
					{
						ResistanceValue = FMath::Floor(ResistanceValue * (1 + Effect.Value / 100));
					}
					else
					{
						ResistanceValue += Effect.Value;
					}
				}
			}
		}
	}

	//TODO a eso agregarle cualquier modificacion surgida por el equipamiento

	//TODO finalmente tener en cuenta cualquier status que pueda afectar

	return ResistanceValue;
}

const int32 ABaseUnit::GetStatResistance(UnitType DamageType)
{
	switch (DamageType)
	{
	case UnitType::Bug:
		return BaseStats.Resistances.Bug + ModifierStats.Resistances.Bug;
		break;
	case UnitType::Dark:
		return BaseStats.Resistances.Dark + ModifierStats.Resistances.Dark;
		break;
	case UnitType::Dragon:
		return BaseStats.Resistances.Dragon + ModifierStats.Resistances.Dragon;
		break;
	case UnitType::Electric:
		return BaseStats.Resistances.Electric + ModifierStats.Resistances.Electric;
		break;
	case UnitType::Fairy:
		return BaseStats.Resistances.Fairy + ModifierStats.Resistances.Fairy;
		break;
	case UnitType::Fighting:
		return BaseStats.Resistances.Fighting + ModifierStats.Resistances.Fighting;
		break;
	case UnitType::Fire:
		return BaseStats.Resistances.Fire + ModifierStats.Resistances.Fire;
		break;
	case UnitType::Flying:
		return BaseStats.Resistances.Flying + ModifierStats.Resistances.Flying;
		break;
	case UnitType::Ghost:
		return BaseStats.Resistances.Ghost + ModifierStats.Resistances.Ghost;
		break;
	case UnitType::Grass:
		return BaseStats.Resistances.Grass + ModifierStats.Resistances.Grass;
		break;
	case UnitType::Ground:
		return BaseStats.Resistances.Ground + ModifierStats.Resistances.Ground;
		break;
	case UnitType::Ice:
		return BaseStats.Resistances.Ice + ModifierStats.Resistances.Ice;
		break;
	case UnitType::Normal:
		return BaseStats.Resistances.Normal + ModifierStats.Resistances.Normal;
		break;
	case UnitType::Poison:
		return BaseStats.Resistances.Poison + ModifierStats.Resistances.Poison;
		break;
	case UnitType::Psychic:
		return BaseStats.Resistances.Psychic + ModifierStats.Resistances.Psychic;
		break;
	case UnitType::Rock:
		return BaseStats.Resistances.Rock + ModifierStats.Resistances.Rock;
		break;
	case UnitType::Steel:
		return BaseStats.Resistances.Steel + ModifierStats.Resistances.Steel;
		break;
	case UnitType::Water:
		return BaseStats.Resistances.Water + ModifierStats.Resistances.Water;
		break;
	default:
		return 0;
		break;
	}
}